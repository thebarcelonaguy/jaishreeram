import { Component, Input, Output, EventEmitter, ViewChild, Inject, ChangeDetectionStrategy, } from '@angular/core';
import { ROUND_PROGRESS_DEFAULTS } from './round-progress.config';
import * as i0 from "@angular/core";
import * as i1 from "./round-progress.service";
import * as i2 from "./round-progress.ease";
class RoundProgressComponent {
    constructor(service, easing, defaults, ngZone) {
        this.service = service;
        this.easing = easing;
        this.defaults = defaults;
        this.ngZone = ngZone;
        this.currentLinecap = '';
        /** Current value of the progress bar. */
        this.current = 0;
        /** Maximum value of the progress bar. */
        this.max = 0;
        /** Radius of the circle. */
        this.radius = this.defaults.radius;
        /** Name of the easing function to use when animating. */
        this.animation = this.defaults.animation;
        /** Time in millisconds by which to delay the animation. */
        this.animationDelay = this.defaults.animationDelay;
        /** Duration of the animation. */
        this.duration = this.defaults.duration;
        /** Width of the circle's stroke. */
        this.stroke = this.defaults.stroke;
        /** Color of the circle. */
        this.color = this.defaults.color;
        /** Background color of the circle. */
        this.background = this.defaults.background;
        /** Whether the circle should take up the width of its parent. */
        this.responsive = this.defaults.responsive;
        /** Whether the circle is filling up clockwise. */
        this.clockwise = this.defaults.clockwise;
        /** Whether to render a semicircle. */
        this.semicircle = this.defaults.semicircle;
        /** Whether the tip of the progress should be rounded off. */
        this.rounded = this.defaults.rounded;
        /** Emits when a new value has been rendered. */
        this.onRender = new EventEmitter();
        this.lastAnimationId = 0;
    }
    /** Animates a change in the current value. */
    _animateChange(from, to) {
        if (typeof from !== 'number') {
            from = 0;
        }
        to = this._clamp(to);
        from = this._clamp(from);
        const self = this;
        const changeInValue = to - from;
        const duration = self.duration;
        // Avoid firing change detection for each of the animation frames.
        self.ngZone.runOutsideAngular(() => {
            const start = () => {
                const startTime = self.service.getTimestamp();
                const id = ++self.lastAnimationId;
                requestAnimationFrame(function animation() {
                    const currentTime = Math.min(self.service.getTimestamp() - startTime, duration);
                    const easingFn = self.easing[self.animation];
                    const value = easingFn(currentTime, from, changeInValue, duration);
                    self._updatePath(value);
                    if (self.onRender.observers.length > 0) {
                        self.onRender.emit(value);
                    }
                    if (id === self.lastAnimationId && currentTime < duration) {
                        requestAnimationFrame(animation);
                    }
                });
            };
            if (this.animationDelay > 0) {
                setTimeout(start, this.animationDelay);
            }
            else {
                start();
            }
        });
    }
    /** Updates the path apperance. */
    _updatePath(value) {
        if (this.path) {
            const arc = this.service.getArc(value, this.max, this.radius - this.stroke / 2, this.radius, this.semicircle);
            const path = this.path.nativeElement;
            // Remove the rounded line cap when the value is zero,
            // because SVG won't allow it to disappear completely.
            const linecap = this.rounded && value > 0 ? 'round' : '';
            // This is called on each animation frame so avoid
            // updating the line cap unless it has changed.
            if (linecap !== this.currentLinecap) {
                this.currentLinecap = linecap;
                path.style.strokeLinecap = linecap;
            }
            path.setAttribute('d', arc);
        }
    }
    /** Clamps a value between the maximum and 0. */
    _clamp(value) {
        return Math.max(0, Math.min(value || 0, this.max));
    }
    /** Determines the SVG transforms for the <path> node. */
    getPathTransform() {
        const diameter = this._getDiameter();
        if (this.semicircle) {
            return this.clockwise
                ? `translate(0, ${diameter}) rotate(-90)`
                : `translate(${diameter + ',' + diameter}) rotate(90) scale(-1, 1)`;
        }
        else if (!this.clockwise) {
            return `scale(-1, 1) translate(-${diameter} 0)`;
        }
        return null;
    }
    /** Resolves a color through the service. */
    resolveColor(color) {
        return this.service.resolveColor(color);
    }
    /** Change detection callback. */
    ngOnChanges(changes) {
        if (changes.current) {
            this._animateChange(changes.current.previousValue, changes.current.currentValue);
        }
        else {
            this._updatePath(this.current);
        }
    }
    /** Diameter of the circle. */
    _getDiameter() {
        return this.radius * 2;
    }
    /** The CSS height of the wrapper element. */
    _getElementHeight() {
        if (!this.responsive) {
            return (this.semicircle ? this.radius : this._getDiameter()) + 'px';
        }
        return null;
    }
    /** Viewbox for the SVG element. */
    _getViewBox() {
        const diameter = this._getDiameter();
        return `0 0 ${diameter} ${this.semicircle ? this.radius : diameter}`;
    }
    /** Bottom padding for the wrapper element. */
    _getPaddingBottom() {
        if (this.responsive) {
            return this.semicircle ? '50%' : '100%';
        }
        return null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: RoundProgressComponent, deps: [{ token: i1.RoundProgressService }, { token: i2.RoundProgressEase }, { token: ROUND_PROGRESS_DEFAULTS }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.4", type: RoundProgressComponent, selector: "round-progress", inputs: { current: "current", max: "max", radius: "radius", animation: "animation", animationDelay: "animationDelay", duration: "duration", stroke: "stroke", color: "color", background: "background", responsive: "responsive", clockwise: "clockwise", semicircle: "semicircle", rounded: "rounded" }, outputs: { onRender: "onRender" }, host: { attributes: { "role": "progressbar" }, properties: { "attr.aria-valuemin": "0", "attr.aria-valuemax": "max", "attr.aria-valuenow": "current", "style.width": "responsive ? \"\" : _getDiameter() + \"px\"", "style.height": "_getElementHeight()", "style.padding-bottom": "_getPaddingBottom()", "class.responsive": "responsive" } }, viewQueries: [{ propertyName: "path", first: true, predicate: ["path"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<svg xmlns=\"http://www.w3.org/2000/svg\" [attr.viewBox]=\"_getViewBox()\">\n  <circle\n    fill=\"none\"\n    [attr.cx]=\"radius\"\n    [attr.cy]=\"radius\"\n    [attr.r]=\"radius - stroke / 2\"\n    [style.stroke]=\"resolveColor(background)\"\n    [style.stroke-width]=\"stroke\"/>\n\n  <path\n    #path\n    fill=\"none\"\n    [style.stroke-width]=\"stroke\"\n    [style.stroke]=\"resolveColor(color)\"\n    [attr.transform]=\"getPathTransform()\"/>\n</svg>\n", styles: [":host{display:block;position:relative;overflow:hidden}:host(.responsive){width:100%;padding-bottom:100%}:host(.responsive)>svg{position:absolute;width:100%;height:100%;top:0;left:0}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { RoundProgressComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: RoundProgressComponent, decorators: [{
            type: Component,
            args: [{ selector: 'round-progress', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        'role': 'progressbar',
                        '[attr.aria-valuemin]': '0',
                        '[attr.aria-valuemax]': 'max',
                        '[attr.aria-valuenow]': 'current',
                        '[style.width]': 'responsive ? "" : _getDiameter() + "px"',
                        '[style.height]': '_getElementHeight()',
                        '[style.padding-bottom]': '_getPaddingBottom()',
                        '[class.responsive]': 'responsive',
                    }, template: "<svg xmlns=\"http://www.w3.org/2000/svg\" [attr.viewBox]=\"_getViewBox()\">\n  <circle\n    fill=\"none\"\n    [attr.cx]=\"radius\"\n    [attr.cy]=\"radius\"\n    [attr.r]=\"radius - stroke / 2\"\n    [style.stroke]=\"resolveColor(background)\"\n    [style.stroke-width]=\"stroke\"/>\n\n  <path\n    #path\n    fill=\"none\"\n    [style.stroke-width]=\"stroke\"\n    [style.stroke]=\"resolveColor(color)\"\n    [attr.transform]=\"getPathTransform()\"/>\n</svg>\n", styles: [":host{display:block;position:relative;overflow:hidden}:host(.responsive){width:100%;padding-bottom:100%}:host(.responsive)>svg{position:absolute;width:100%;height:100%;top:0;left:0}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.RoundProgressService }, { type: i2.RoundProgressEase }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [ROUND_PROGRESS_DEFAULTS]
                }] }, { type: i0.NgZone }]; }, propDecorators: { path: [{
                type: ViewChild,
                args: ['path']
            }], current: [{
                type: Input
            }], max: [{
                type: Input
            }], radius: [{
                type: Input
            }], animation: [{
                type: Input
            }], animationDelay: [{
                type: Input
            }], duration: [{
                type: Input
            }], stroke: [{
                type: Input
            }], color: [{
                type: Input
            }], background: [{
                type: Input
            }], responsive: [{
                type: Input
            }], clockwise: [{
                type: Input
            }], semicircle: [{
                type: Input
            }], rounded: [{
                type: Input
            }], onRender: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91bmQtcHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9yb3VuZC1wcm9ncmVzcy9yb3VuZC1wcm9ncmVzcy5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9zcmMvbGliL3JvdW5kLXByb2dyZXNzL3JvdW5kLXByb2dyZXNzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFHTixZQUFZLEVBQ1osU0FBUyxFQUNULE1BQU0sRUFHTix1QkFBdUIsR0FDeEIsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFDLHVCQUF1QixFQUF3QixNQUFNLHlCQUF5QixDQUFDOzs7O0FBR3ZGLE1BZ0JhLHNCQUFzQjtJQWtEakMsWUFDVSxPQUE2QixFQUM3QixNQUF5QixFQUNRLFFBQStCLEVBQ2hFLE1BQWM7UUFIZCxZQUFPLEdBQVAsT0FBTyxDQUFzQjtRQUM3QixXQUFNLEdBQU4sTUFBTSxDQUFtQjtRQUNRLGFBQVEsR0FBUixRQUFRLENBQXVCO1FBQ2hFLFdBQU0sR0FBTixNQUFNLENBQVE7UUFyRGhCLG1CQUFjLEdBQWlCLEVBQUUsQ0FBQztRQUsxQyx5Q0FBeUM7UUFDaEMsWUFBTyxHQUFXLENBQUMsQ0FBQztRQUU3Qix5Q0FBeUM7UUFDaEMsUUFBRyxHQUFXLENBQUMsQ0FBQztRQUV6Qiw0QkFBNEI7UUFDbkIsV0FBTSxHQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTyxDQUFDO1FBRWhELHlEQUF5RDtRQUNoRCxjQUFTLEdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFVLENBQUM7UUFFdEQsMkRBQTJEO1FBQ2xELG1CQUFjLEdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFlLENBQUM7UUFFaEUsaUNBQWlDO1FBQ3hCLGFBQVEsR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVMs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SztnQkFHRyxVQUFVO3NCQUFsQixLQUFLO2dCQUdHLE9BQU87c0JBQWYsS0FBSztnQkFHSSxRQUFRO3NCQUFqQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBPbkNoYW5nZXMsXG4gIE5nWm9uZSxcbiAgRXZlbnRFbWl0dGVyLFxuICBWaWV3Q2hpbGQsXG4gIEluamVjdCxcbiAgRWxlbWVudFJlZixcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1JvdW5kUHJvZ3Jlc3NTZXJ2aWNlfSBmcm9tICcuL3JvdW5kLXByb2dyZXNzLnNlcnZpY2UnO1xuaW1wb3J0IHtST1VORF9QUk9HUkVTU19ERUZBVUxUUywgUm91bmRQcm9ncmVzc0RlZmF1bHRzfSBmcm9tICcuL3JvdW5kLXByb2dyZXNzLmNvbmZpZyc7XG5pbXBvcnQge1JvdW5kUHJvZ3Jlc3NFYXNlfSBmcm9tICcuL3JvdW5kLXByb2dyZXNzLmVhc2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdyb3VuZC1wcm9ncmVzcycsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICB0ZW1wbGF0ZVVybDogJy4vcm91bmQtcHJvZ3Jlc3MuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9yb3VuZC1wcm9ncmVzcy5jb21wb25lbnQuY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAncm9sZSc6ICdwcm9ncmVzc2JhcicsXG4gICAgJ1thdHRyLmFyaWEtdmFsdWVtaW5dJzogJzAnLFxuICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdtYXgnLFxuICAgICdbYXR0ci5hcmlhLXZhbHVlbm93XSc6ICdjdXJyZW50JyxcbiAgICAnW3N0eWxlLndpZHRoXSc6ICdyZXNwb25zaXZlID8gXCJcIiA6IF9nZXREaWFtZXRlcigpICsgXCJweFwiJyxcbiAgICAnW3N0eWxlLmhlaWdodF0nOiAnX2dldEVsZW1lbnRIZWlnaHQoKScsXG4gICAgJ1tzdHlsZS5wYWRkaW5nLWJvdHRvbV0nOiAnX2dldFBhZGRpbmdCb3R0b20oKScsXG4gICAgJ1tjbGFzcy5yZXNwb25zaXZlXSc6ICdyZXNwb25zaXZlJyxcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBSb3VuZFByb2dyZXNzQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgcHJpdmF0ZSBjdXJyZW50TGluZWNhcDogJ3JvdW5kJyB8ICcnID0gJyc7XG5cbiAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBgcGF0aGAgbm9kZS4gKi9cbiAgQFZpZXdDaGlsZCgncGF0aCcpIHBhdGghOiBFbGVtZW50UmVmPFNWR1BhdGhFbGVtZW50PjtcblxuICAvKiogQ3VycmVudCB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xuICBASW5wdXQoKSBjdXJyZW50OiBudW1iZXIgPSAwO1xuXG4gIC8qKiBNYXhpbXVtIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBiYXIuICovXG4gIEBJbnB1dCgpIG1heDogbnVtYmVyID0gMDtcblxuICAvKiogUmFkaXVzIG9mIHRoZSBjaXJjbGUuICovXG4gIEBJbnB1dCgpIHJhZGl1czogbnVtYmVyID0gdGhpcy5kZWZhdWx0cy5yYWRpdXMhO1xuXG4gIC8qKiBOYW1lIG9mIHRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gYW5pbWF0aW5nLiAqL1xuICBASW5wdXQoKSBhbmltYXRpb246IHN0cmluZyA9IHRoaXMuZGVmYXVsdHMuYW5pbWF0aW9uITtcblxuICAvKiogVGltZSBpbiBtaWxsaXNjb25kcyBieSB3aGljaCB0byBkZWxheSB0aGUgYW5pbWF0aW9uLiAqL1xuICBASW5wdXQoKSBhbmltYXRpb25EZWxheTogbnVtYmVyID0gdGhpcy5kZWZhdWx0cy5hbmltYXRpb25EZWxheSE7XG5cbiAgLyoqIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uICovXG4gIEBJbnB1dCgpIGR1cmF0aW9uOiBudW1iZXIgPSB0aGlzLmRlZmF1bHRzLmR1cmF0aW9uITtcblxuICAvKiogV2lkdGggb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS4gKi9cbiAgQElucHV0KCkgc3Ryb2tlOiBudW1iZXIgPSB0aGlzLmRlZmF1bHRzLnN0cm9rZSE7XG5cbiAgLyoqIENvbG9yIG9mIHRoZSBjaXJjbGUuICovXG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmcgPSB0aGlzLmRlZmF1bHRzLmNvbG9yITtcblxuICAvKiogQmFja2dyb3VuZCBjb2xvciBvZiB0aGUgY2lyY2xlLiAqL1xuICBASW5wdXQoKSBiYWNrZ3JvdW5kOiBzdHJpbmcgPSB0aGlzLmRlZmF1bHRzLmJhY2tncm91bmQhO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBjaXJjbGUgc2hvdWxkIHRha2UgdXAgdGhlIHdpZHRoIG9mIGl0cyBwYXJlbnQuICovXG4gIEBJbnB1dCgpIHJlc3BvbnNpdmU6IGJvb2xlYW4gPSB0aGlzLmRlZmF1bHRzLnJlc3BvbnNpdmUhO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBjaXJjbGUgaXMgZmlsbGluZyB1cCBjbG9ja3dpc2UuICovXG4gIEBJbnB1dCgpIGNsb2Nrd2lzZTogYm9vbGVhbiA9IHRoaXMuZGVmYXVsdHMuY2xvY2t3aXNlITtcblxuICAvKiogV2hldGhlciB0byByZW5kZXIgYSBzZW1pY2lyY2xlLiAqL1xuICBASW5wdXQoKSBzZW1pY2lyY2xlOiBib29sZWFuID0gdGhpcy5kZWZhdWx0cy5zZW1pY2lyY2xlITtcblxuICAvKiogV2hldGhlciB0aGUgdGlwIG9mIHRoZSBwcm9ncmVzcyBzaG91bGQgYmUgcm91bmRlZCBvZmYuICovXG4gIEBJbnB1dCgpIHJvdW5kZWQ6IGJvb2xlYW4gPSB0aGlzLmRlZmF1bHRzLnJvdW5kZWQhO1xuXG4gIC8qKiBFbWl0cyB3aGVuIGEgbmV3IHZhbHVlIGhhcyBiZWVuIHJlbmRlcmVkLiAqL1xuICBAT3V0cHV0KCkgb25SZW5kZXI6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHByaXZhdGUgbGFzdEFuaW1hdGlvbklkID0gMDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHNlcnZpY2U6IFJvdW5kUHJvZ3Jlc3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWFzaW5nOiBSb3VuZFByb2dyZXNzRWFzZSxcbiAgICBASW5qZWN0KFJPVU5EX1BST0dSRVNTX0RFRkFVTFRTKSBwcml2YXRlIGRlZmF1bHRzOiBSb3VuZFByb2dyZXNzRGVmYXVsdHMsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZVxuICApIHt9XG5cbiAgLyoqIEFuaW1hdGVzIGEgY2hhbmdlIGluIHRoZSBjdXJyZW50IHZhbHVlLiAqL1xuICBwcml2YXRlIF9hbmltYXRlQ2hhbmdlKGZyb206IG51bWJlciwgdG86IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGZyb20gPSAwO1xuICAgIH1cblxuICAgIHRvID0gdGhpcy5fY2xhbXAodG8pO1xuICAgIGZyb20gPSB0aGlzLl9jbGFtcChmcm9tKTtcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZUluVmFsdWUgPSB0byAtIGZyb207XG4gICAgY29uc3QgZHVyYXRpb24gPSBzZWxmLmR1cmF0aW9uO1xuXG4gICAgLy8gQXZvaWQgZmlyaW5nIGNoYW5nZSBkZXRlY3Rpb24gZm9yIGVhY2ggb2YgdGhlIGFuaW1hdGlvbiBmcmFtZXMuXG4gICAgc2VsZi5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNlbGYuc2VydmljZS5nZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgY29uc3QgaWQgPSArK3NlbGYubGFzdEFuaW1hdGlvbklkO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRpb24oKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBNYXRoLm1pbihzZWxmLnNlcnZpY2UuZ2V0VGltZXN0YW1wKCkgLSBzdGFydFRpbWUsIGR1cmF0aW9uKTtcbiAgICAgICAgICBjb25zdCBlYXNpbmdGbiA9IHNlbGYuZWFzaW5nW3NlbGYuYW5pbWF0aW9uIGFzIGtleW9mIFJvdW5kUHJvZ3Jlc3NFYXNlXTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVhc2luZ0ZuKGN1cnJlbnRUaW1lLCBmcm9tLCBjaGFuZ2VJblZhbHVlLCBkdXJhdGlvbik7XG5cbiAgICAgICAgICBzZWxmLl91cGRhdGVQYXRoKHZhbHVlKTtcblxuICAgICAgICAgIGlmIChzZWxmLm9uUmVuZGVyLm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLm9uUmVuZGVyLmVtaXQodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpZCA9PT0gc2VsZi5sYXN0QW5pbWF0aW9uSWQgJiYgY3VycmVudFRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkRlbGF5ID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KHN0YXJ0LCB0aGlzLmFuaW1hdGlvbkRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgcGF0aCBhcHBlcmFuY2UuICovXG4gIHByaXZhdGUgX3VwZGF0ZVBhdGgodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgIGNvbnN0IGFyYyA9IHRoaXMuc2VydmljZS5nZXRBcmModmFsdWUsIHRoaXMubWF4LCB0aGlzLnJhZGl1cyAtIHRoaXMuc3Ryb2tlIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMsIHRoaXMuc2VtaWNpcmNsZSk7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgcm91bmRlZCBsaW5lIGNhcCB3aGVuIHRoZSB2YWx1ZSBpcyB6ZXJvLFxuICAgICAgLy8gYmVjYXVzZSBTVkcgd29uJ3QgYWxsb3cgaXQgdG8gZGlzYXBwZWFyIGNvbXBsZXRlbHkuXG4gICAgICBjb25zdCBsaW5lY2FwID0gdGhpcy5yb3VuZGVkICYmIHZhbHVlID4gMCA/ICdyb3VuZCcgOiAnJztcblxuICAgICAgLy8gVGhpcyBpcyBjYWxsZWQgb24gZWFjaCBhbmltYXRpb24gZnJhbWUgc28gYXZvaWRcbiAgICAgIC8vIHVwZGF0aW5nIHRoZSBsaW5lIGNhcCB1bmxlc3MgaXQgaGFzIGNoYW5nZWQuXG4gICAgICBpZiAobGluZWNhcCAhPT0gdGhpcy5jdXJyZW50TGluZWNhcCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lY2FwID0gbGluZWNhcDtcbiAgICAgICAgcGF0aC5zdHlsZS5zdHJva2VMaW5lY2FwID0gbGluZWNhcDtcbiAgICAgIH1cblxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBhcmMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDbGFtcHMgYSB2YWx1ZSBiZXR3ZWVuIHRoZSBtYXhpbXVtIGFuZCAwLiAqL1xuICBwcml2YXRlIF9jbGFtcCh2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4odmFsdWUgfHwgMCwgdGhpcy5tYXgpKTtcbiAgfVxuXG4gIC8qKiBEZXRlcm1pbmVzIHRoZSBTVkcgdHJhbnNmb3JtcyBmb3IgdGhlIDxwYXRoPiBub2RlLiAqL1xuICBnZXRQYXRoVHJhbnNmb3JtKCk6IHN0cmluZ3xudWxsIHtcbiAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMuX2dldERpYW1ldGVyKCk7XG5cbiAgICBpZiAodGhpcy5zZW1pY2lyY2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9ja3dpc2VcbiAgICAgICAgPyBgdHJhbnNsYXRlKDAsICR7ZGlhbWV0ZXJ9KSByb3RhdGUoLTkwKWBcbiAgICAgICAgOiBgdHJhbnNsYXRlKCR7ZGlhbWV0ZXIgKyAnLCcgKyBkaWFtZXRlcn0pIHJvdGF0ZSg5MCkgc2NhbGUoLTEsIDEpYDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNsb2Nrd2lzZSkge1xuICAgICAgcmV0dXJuIGBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC0ke2RpYW1ldGVyfSAwKWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogUmVzb2x2ZXMgYSBjb2xvciB0aHJvdWdoIHRoZSBzZXJ2aWNlLiAqL1xuICByZXNvbHZlQ29sb3IoY29sb3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5yZXNvbHZlQ29sb3IoY29sb3IpO1xuICB9XG5cbiAgLyoqIENoYW5nZSBkZXRlY3Rpb24gY2FsbGJhY2suICovXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLl9hbmltYXRlQ2hhbmdlKGNoYW5nZXMuY3VycmVudC5wcmV2aW91c1ZhbHVlLCBjaGFuZ2VzLmN1cnJlbnQuY3VycmVudFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlUGF0aCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBEaWFtZXRlciBvZiB0aGUgY2lyY2xlLiAqL1xuICBfZ2V0RGlhbWV0ZXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXMgKiAyO1xuICB9XG5cbiAgLyoqIFRoZSBDU1MgaGVpZ2h0IG9mIHRoZSB3cmFwcGVyIGVsZW1lbnQuICovXG4gIF9nZXRFbGVtZW50SGVpZ2h0KCk6IHN0cmluZ3xudWxsIHtcbiAgICBpZiAoIXRoaXMucmVzcG9uc2l2ZSkge1xuICAgICAgcmV0dXJuICh0aGlzLnNlbWljaXJjbGUgPyB0aGlzLnJhZGl1cyA6IHRoaXMuX2dldERpYW1ldGVyKCkpICsgJ3B4JztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBWaWV3Ym94IGZvciB0aGUgU1ZHIGVsZW1lbnQuICovXG4gIF9nZXRWaWV3Qm94KCk6IHN0cmluZyB7XG4gICAgY29uc3QgZGlhbWV0ZXIgPSB0aGlzLl9nZXREaWFtZXRlcigpO1xuICAgIHJldHVybiBgMCAwICR7ZGlhbWV0ZXJ9ICR7dGhpcy5zZW1pY2lyY2xlID8gdGhpcy5yYWRpdXMgOiBkaWFtZXRlcn1gO1xuICB9XG5cbiAgLyoqIEJvdHRvbSBwYWRkaW5nIGZvciB0aGUgd3JhcHBlciBlbGVtZW50LiAqL1xuICBfZ2V0UGFkZGluZ0JvdHRvbSgpOiBzdHJpbmd8bnVsbCB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2l2ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VtaWNpcmNsZSA/ICc1MCUnIDogJzEwMCUnO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCI8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBbYXR0ci52aWV3Qm94XT1cIl9nZXRWaWV3Qm94KClcIj5cbiAgPGNpcmNsZVxuICAgIGZpbGw9XCJub25lXCJcbiAgICBbYXR0ci5jeF09XCJyYWRpdXNcIlxuICAgIFthdHRyLmN5XT1cInJhZGl1c1wiXG4gICAgW2F0dHIucl09XCJyYWRpdXMgLSBzdHJva2UgLyAyXCJcbiAgICBbc3R5bGUuc3Ryb2tlXT1cInJlc29sdmVDb2xvcihiYWNrZ3JvdW5kKVwiXG4gICAgW3N0eWxlLnN0cm9rZS13aWR0aF09XCJzdHJva2VcIi8+XG5cbiAgPHBhdGhcbiAgICAjcGF0aFxuICAgIGZpbGw9XCJub25lXCJcbiAgICBbc3R5bGUuc3Ryb2tlLXdpZHRoXT1cInN0cm9rZVwiXG4gICAgW3N0eWxlLnN0cm9rZV09XCJyZXNvbHZlQ29sb3IoY29sb3IpXCJcbiAgICBbYXR0ci50cmFuc2Zvcm1dPVwiZ2V0UGF0aFRyYW5zZm9ybSgpXCIvPlxuPC9zdmc+XG4iXX0=