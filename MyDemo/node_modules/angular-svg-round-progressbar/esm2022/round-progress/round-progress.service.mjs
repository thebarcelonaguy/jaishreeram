import { Injectable, Inject, Optional } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import * as i0 from "@angular/core";
const DEGREE_IN_RADIANS = Math.PI / 180;
class RoundProgressService {
    constructor(document) {
        this.supportsSvg = !!(document &&
            document.createElementNS &&
            document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);
        this.base = document && document.head.querySelector('base');
        this.hasPerf =
            typeof window !== 'undefined' &&
                window.performance &&
                window.performance.now &&
                typeof window.performance.now() === 'number';
    }
    /**
     * Resolves a SVG color against the page's `base` tag.
     */
    resolveColor(color) {
        if (this.base && this.base.href) {
            const hashIndex = color.indexOf('#');
            if (hashIndex > -1 && color.indexOf('url') > -1) {
                return color.slice(0, hashIndex) + location.href + color.slice(hashIndex);
            }
        }
        return color;
    }
    /**
     * Generates a timestamp.
     */
    getTimestamp() {
        return this.hasPerf ? window.performance.now() : Date.now();
    }
    /**
     * Generates the value for an SVG arc.
     *
     * @param current Current value.
     * @param total Maximum value.
     * @param pathRadius Radius of the SVG path.
     * @param elementRadius Radius of the SVG container.
     * @param isSemicircle Whether the element should be a semicircle.
     */
    getArc(current, total, pathRadius, elementRadius, isSemicircle = false) {
        const value = Math.max(0, Math.min(current || 0, total));
        const maxAngle = isSemicircle ? 180 : 359.9999;
        const percentage = total === 0 ? maxAngle : (value / total) * maxAngle;
        const start = this._polarToCartesian(elementRadius, pathRadius, percentage);
        const end = this._polarToCartesian(elementRadius, pathRadius, 0);
        const arcSweep = percentage <= 180 ? 0 : 1;
        return `M ${start} A ${pathRadius} ${pathRadius} 0 ${arcSweep} 0 ${end}`;
    }
    /**
     * Converts polar cooradinates to Cartesian.
     *
     * @param elementRadius Radius of the wrapper element.
     * @param pathRadius Radius of the path being described.
     * @param angleInDegrees Degree to be converted.
     */
    _polarToCartesian(elementRadius, pathRadius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
        const x = elementRadius + pathRadius * Math.cos(angleInRadians);
        const y = elementRadius + pathRadius * Math.sin(angleInRadians);
        return x + ' ' + y;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: RoundProgressService, deps: [{ token: DOCUMENT, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: RoundProgressService, providedIn: 'root' }); }
}
export { RoundProgressService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: RoundProgressService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91bmQtcHJvZ3Jlc3Muc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvcm91bmQtcHJvZ3Jlc3Mvcm91bmQtcHJvZ3Jlc3Muc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDM0QsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDOztBQUV6QyxNQUFNLGlCQUFpQixHQUFXLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDO0FBRWhELE1BQ2Esb0JBQW9CO0lBSy9CLFlBQTBDLFFBQWE7UUFDckQsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FDbkIsUUFBUTtZQUNSLFFBQVEsQ0FBQyxlQUFlO1lBQ3hCLFFBQVEsQ0FBQyxlQUFlLENBQUMsNEJBQTRCLEVBQUUsS0FBSyxDQUFDLENBQUMsYUFBYSxDQUM1RSxDQUFDO1FBRUYsSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLE9BQU87WUFDVixPQUFPLE1BQU0sS0FBSyxXQUFXO2dCQUM3QixNQUFNLENBQUMsV0FBVztnQkFDbEIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHO2dCQUN0QixPQUFPLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEtBQUssUUFBUSxDQUFDO0lBQ2pELENBQUM7SUFFRDs7T0FFRztJQUNILFlBQVksQ0FBQyxLQUFhO1FBQ3hCLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUMvQixNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRXJDLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Z0JBQy9DLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQzNFO1NBQ0Y7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNILFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxNQUFNLENBQUMsT0FBZSxFQUFFLEtBQWEsRUFBRSxVQUFrQixFQUFFLGFBQXFCLEVBQ3pFLFlBQVksR0FBRyxLQUFLO1FBQ3pCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7UUFDL0MsTUFBTSxVQUFVLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUM7UUFDdkUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDNUUsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDakUsTUFBTSxRQUFRLEdBQUcsVUFBVSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFM0MsT0FBTyxLQUFLLEtBQUssTUFBTSxVQUFVLElBQUksVUFBVSxNQUFNLFFBQVEsTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssaUJBQWlCLENBQUMsYUFBcUIsRUFBRSxVQUFrQixFQUN6QyxjQUFzQjtRQUM5QyxNQUFNLGNBQWMsR0FBRyxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUMsR0FBRyxpQkFBaUIsQ0FBQztRQUNqRSxNQUFNLENBQUMsR0FBRyxhQUFhLEdBQUcsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDaEUsTUFBTSxDQUFDLEdBQUcsYUFBYSxHQUFHLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRWhFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDckIsQ0FBQzs4R0E3RVUsb0JBQW9CLGtCQUtDLFFBQVE7a0hBTDdCLG9CQUFvQixjQURSLE1BQU07O1NBQ2xCLG9CQUFvQjsyRkFBcEIsb0JBQW9CO2tCQURoQyxVQUFVO21CQUFDLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBQzs7MEJBTWpCLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZSwgSW5qZWN0LCBPcHRpb25hbH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RPQ1VNRU5UfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5jb25zdCBERUdSRUVfSU5fUkFESUFOUzogbnVtYmVyID0gTWF0aC5QSSAvIDE4MDtcblxuQEluamVjdGFibGUoe3Byb3ZpZGVkSW46ICdyb290J30pXG5leHBvcnQgY2xhc3MgUm91bmRQcm9ncmVzc1NlcnZpY2Uge1xuICBwcml2YXRlIGJhc2U6IEhUTUxCYXNlRWxlbWVudDtcbiAgcHJpdmF0ZSBoYXNQZXJmOiBib29sZWFuO1xuICBwdWJsaWMgc3VwcG9ydHNTdmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgZG9jdW1lbnQ6IGFueSkge1xuICAgIHRoaXMuc3VwcG9ydHNTdmcgPSAhIShcbiAgICAgIGRvY3VtZW50ICYmXG4gICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiZcbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJykuY3JlYXRlU1ZHUmVjdFxuICAgICk7XG5cbiAgICB0aGlzLmJhc2UgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICB0aGlzLmhhc1BlcmYgPVxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZSAmJlxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyAmJlxuICAgICAgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA9PT0gJ251bWJlcic7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBTVkcgY29sb3IgYWdhaW5zdCB0aGUgcGFnZSdzIGBiYXNlYCB0YWcuXG4gICAqL1xuICByZXNvbHZlQ29sb3IoY29sb3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuYmFzZSAmJiB0aGlzLmJhc2UuaHJlZikge1xuICAgICAgY29uc3QgaGFzaEluZGV4ID0gY29sb3IuaW5kZXhPZignIycpO1xuXG4gICAgICBpZiAoaGFzaEluZGV4ID4gLTEgJiYgY29sb3IuaW5kZXhPZigndXJsJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gY29sb3Iuc2xpY2UoMCwgaGFzaEluZGV4KSArIGxvY2F0aW9uLmhyZWYgKyBjb2xvci5zbGljZShoYXNoSW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB0aW1lc3RhbXAuXG4gICAqL1xuICBnZXRUaW1lc3RhbXAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5oYXNQZXJmID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHZhbHVlIGZvciBhbiBTVkcgYXJjLlxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudCBDdXJyZW50IHZhbHVlLlxuICAgKiBAcGFyYW0gdG90YWwgTWF4aW11bSB2YWx1ZS5cbiAgICogQHBhcmFtIHBhdGhSYWRpdXMgUmFkaXVzIG9mIHRoZSBTVkcgcGF0aC5cbiAgICogQHBhcmFtIGVsZW1lbnRSYWRpdXMgUmFkaXVzIG9mIHRoZSBTVkcgY29udGFpbmVyLlxuICAgKiBAcGFyYW0gaXNTZW1pY2lyY2xlIFdoZXRoZXIgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGEgc2VtaWNpcmNsZS5cbiAgICovXG4gIGdldEFyYyhjdXJyZW50OiBudW1iZXIsIHRvdGFsOiBudW1iZXIsIHBhdGhSYWRpdXM6IG51bWJlciwgZWxlbWVudFJhZGl1czogbnVtYmVyLFxuICAgICAgICAgaXNTZW1pY2lyY2xlID0gZmFsc2UpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3VycmVudCB8fCAwLCB0b3RhbCkpO1xuICAgIGNvbnN0IG1heEFuZ2xlID0gaXNTZW1pY2lyY2xlID8gMTgwIDogMzU5Ljk5OTk7XG4gICAgY29uc3QgcGVyY2VudGFnZSA9IHRvdGFsID09PSAwID8gbWF4QW5nbGUgOiAodmFsdWUgLyB0b3RhbCkgKiBtYXhBbmdsZTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX3BvbGFyVG9DYXJ0ZXNpYW4oZWxlbWVudFJhZGl1cywgcGF0aFJhZGl1cywgcGVyY2VudGFnZSk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5fcG9sYXJUb0NhcnRlc2lhbihlbGVtZW50UmFkaXVzLCBwYXRoUmFkaXVzLCAwKTtcbiAgICBjb25zdCBhcmNTd2VlcCA9IHBlcmNlbnRhZ2UgPD0gMTgwID8gMCA6IDE7XG5cbiAgICByZXR1cm4gYE0gJHtzdGFydH0gQSAke3BhdGhSYWRpdXN9ICR7cGF0aFJhZGl1c30gMCAke2FyY1N3ZWVwfSAwICR7ZW5kfWA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgcG9sYXIgY29vcmFkaW5hdGVzIHRvIENhcnRlc2lhbi5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnRSYWRpdXMgUmFkaXVzIG9mIHRoZSB3cmFwcGVyIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBwYXRoUmFkaXVzIFJhZGl1cyBvZiB0aGUgcGF0aCBiZWluZyBkZXNjcmliZWQuXG4gICAqIEBwYXJhbSBhbmdsZUluRGVncmVlcyBEZWdyZWUgdG8gYmUgY29udmVydGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfcG9sYXJUb0NhcnRlc2lhbihlbGVtZW50UmFkaXVzOiBudW1iZXIsIHBhdGhSYWRpdXM6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmdsZUluRGVncmVlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcyAtIDkwKSAqIERFR1JFRV9JTl9SQURJQU5TO1xuICAgIGNvbnN0IHggPSBlbGVtZW50UmFkaXVzICsgcGF0aFJhZGl1cyAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICBjb25zdCB5ID0gZWxlbWVudFJhZGl1cyArIHBhdGhSYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG5cbiAgICByZXR1cm4geCArICcgJyArIHk7XG4gIH1cbn1cbiJdfQ==